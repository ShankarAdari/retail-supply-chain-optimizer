# Real-Time Features Documentation

## Overview

The Retail Supply Chain Optimizer includes a comprehensive real-time dashboard powered by WebSocket technology. This enables live KPI updates, instant alerts, and real-time performance monitoring without page refreshes.

## Architecture

### Backend Components

#### WebSocket Server (`server/websocket.ts`)
- **Purpose**: Manages real-time connections and KPI streaming
- **Key Features**:
  - Persistent WebSocket connections using Socket.io
  - Automatic reconnection with exponential backoff
  - KPI data streaming at 5-second intervals
  - Alert generation and broadcasting
  - Connection status tracking

#### WebSocket Manager Methods
```typescript
// Subscribe to KPI updates for a store
socket.emit('subscribe_kpi', { storeId: 1, userId: 'user123' });

// Manually refresh KPI data
socket.emit('refresh_kpi', { storeId: 1 });

// Acknowledge alert (removes from queue)
socket.emit('acknowledge_alert', { alertId: 'alert_123' });
```

### Frontend Components

#### useRealtimeKPI Hook (`client/src/hooks/useRealtimeKPI.ts`)
- **Purpose**: React hook for WebSocket connection management
- **Returns**:
  - `kpiData`: Current KPI metrics
  - `alerts`: Array of active alerts
  - `connectionStatus`: Connection state and update frequency
  - `isLoading`: Initial connection state
  - `error`: Connection errors
  - `refreshKPI()`: Manual refresh function
  - `acknowledgeAlert()`: Dismiss alert
  - `clearAlerts()`: Clear all alerts

#### Real-Time Dashboard (`client/src/pages/RealtimeDashboard.tsx`)
- **Features**:
  - Live KPI cards with animated values
  - Real-time trend charts (last 20 data points)
  - Connection status indicator
  - Toast notifications for critical alerts
  - Alert management interface
  - Store selection dropdown
  - Manual refresh button

## Real-Time KPI Updates

### Update Frequency
- Default: Every 5 seconds
- Configurable via `connectionStatus.updateFrequency`

### KPI Metrics Streamed
```typescript
interface KPIUpdate {
  storeId: number;
  timestamp: Date;
  inventoryTurnover: number;
  daysOfInventory: number;
  grossProfitMargin: number;
  orderFillRate: number;
  stockoutRate: number;
  onTimeDeliveryRate: number;
  returnRate: number;
  totalRevenue: number;
  totalCost: number;
  status: "good" | "warning" | "critical";
}
```

## Alert System

### Alert Types
1. **Stockout Alert** - Triggered when stockout rate > 10%
2. **Low Performance** - Triggered when order fill rate < 85%
3. **Delivery Delay** - Triggered when on-time delivery rate < 90%
4. **High Demand** - Positive alert when profit margin > 40%

### Alert Severity Levels
- **Critical**: Requires immediate action (red)
- **Warning**: Needs attention (yellow)
- **Info**: Informational (blue)

### Alert Lifecycle
1. Generated by WebSocket server based on KPI thresholds
2. Sent to client via `alert` event
3. Displayed as toast notification
4. Added to alert queue in dashboard
5. Can be dismissed/acknowledged by user
6. Removed from queue when acknowledged

## Connection Management

### Automatic Reconnection
- Reconnection delay: 1 second (initial)
- Max reconnection delay: 5 seconds
- Reconnection attempts: 5
- Transports: WebSocket (primary), Polling (fallback)

### Connection Status Indicators
- **Connected**: Green indicator with "Connected" label
- **Disconnected**: Red indicator with "Disconnected" label
- **Last Update**: Timestamp of most recent KPI update
- **Update Frequency**: Current streaming interval

## Usage Example

```typescript
import { useRealtimeKPI } from '@/hooks/useRealtimeKPI';

function MyComponent() {
  const {
    kpiData,
    alerts,
    connectionStatus,
    isLoading,
    error,
    refreshKPI,
    acknowledgeAlert,
  } = useRealtimeKPI(storeId, userId);

  if (isLoading) return <div>Connecting...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {connectionStatus.connected && (
        <div>
          <h2>Order Fill Rate: {kpiData?.orderFillRate}%</h2>
          <button onClick={refreshKPI}>Refresh</button>
          {alerts.map(alert => (
            <div key={alert.id}>
              {alert.message}
              <button onClick={() => acknowledgeAlert(alert.id)}>Dismiss</button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

## Performance Considerations

### Client-Side Optimization
- Memoized WebSocket hook to prevent unnecessary reconnections
- Efficient state updates using React hooks
- Chart data limited to last 20 points to prevent memory bloat
- Toast notifications deduplicated to prevent spam

### Server-Side Optimization
- KPI data cached to avoid redundant database queries
- Alert generation based on threshold comparison (no complex calculations)
- Connection pooling for database access
- Automatic cleanup of disconnected clients

## Security Considerations

1. **Authentication**: WebSocket connections inherit HTTP authentication
2. **Authorization**: Store access controlled via user permissions
3. **Rate Limiting**: Consider implementing rate limiting for refresh requests
4. **Data Validation**: All incoming data validated before processing
5. **CORS**: Socket.io configured with appropriate CORS settings

## Troubleshooting

### Connection Issues
- Check browser console for WebSocket errors
- Verify server is running and WebSocket port is accessible
- Check firewall/proxy settings for WebSocket support
- Ensure browser supports WebSocket (most modern browsers do)

### Missing Updates
- Verify store ID is correct
- Check connection status indicator
- Try manual refresh button
- Check server logs for errors

### Alert Not Showing
- Verify alert threshold conditions are met
- Check if alert was already dismissed
- Clear browser cache and reload
- Check browser console for JavaScript errors

## Future Enhancements

1. **Configurable Update Frequency**: Allow users to adjust streaming interval
2. **Alert Customization**: Let users set custom thresholds for alerts
3. **Historical Data**: Store and replay real-time data for analysis
4. **Multi-Store Monitoring**: Subscribe to multiple stores simultaneously
5. **Predictive Alerts**: ML-based alerts for anomaly detection
6. **Mobile Optimization**: Optimized WebSocket for mobile networks
7. **Offline Support**: Queue updates when offline, sync when reconnected

## Deployment Notes

### Environment Variables
- Ensure WebSocket port is exposed in production
- Configure CORS for production domain
- Enable SSL/TLS for secure WebSocket (wss://)

### Scaling Considerations
- Use Redis adapter for multi-server deployments
- Implement connection pooling for database
- Monitor memory usage with many concurrent connections
- Consider load balancing for high traffic

## API Reference

### Server Events

#### `subscribe_kpi`
Subscribe to KPI updates for a store
```typescript
socket.emit('subscribe_kpi', { storeId: number, userId: string });
```

#### `unsubscribe_kpi`
Unsubscribe from KPI updates
```typescript
socket.emit('unsubscribe_kpi', { storeId: number });
```

#### `refresh_kpi`
Manually request KPI update
```typescript
socket.emit('refresh_kpi', { storeId: number });
```

#### `acknowledge_alert`
Mark alert as acknowledged
```typescript
socket.emit('acknowledge_alert', { alertId: string });
```

### Client Events

#### `kpi_update`
Received when KPI data is updated
```typescript
socket.on('kpi_update', (update: KPIUpdate) => {
  // Handle update
});
```

#### `alert`
Received when alert is generated
```typescript
socket.on('alert', (alert: Alert) => {
  // Handle alert
});
```

#### `connection_status`
Received on connection establishment
```typescript
socket.on('connection_status', (status: ConnectionStatus) => {
  // Handle status
});
```

#### `kpi_broadcast`
Broadcast KPI update to all subscribed clients
```typescript
socket.on('kpi_broadcast', ({ storeId, update }) => {
  // Handle broadcast
});
```
